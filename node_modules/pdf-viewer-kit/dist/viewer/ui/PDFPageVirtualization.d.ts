import { PageViewport, PDFPageProxy, RenderTask } from 'pdfjs-dist';
import { default as TextLayer } from './PDFTextLayer';
import { default as WebViewer } from './WebViewer';
import { ViewerLoadOptions } from '../../types/webpdf.types';
import { default as AnnotationLayer } from './PDFAnnotationLayer';
import { SelectionManager } from '../manager/SelectionManager';
import { default as SearchHighlighter } from '../manager/SearchHighlighter';
interface CachedPageInfo {
    pageNumber: number;
    pdfPageProxy: PDFPageProxy | null;
    pageWrapperDiv: HTMLDivElement;
    canvasElement?: HTMLCanvasElement;
    renderTask?: RenderTask;
    highResImageBitmap?: ImageBitmap;
    highResRenderTask?: RenderTask;
    textLayer?: TextLayer;
    annotationLayer?: AnnotationLayer;
    isVisible: boolean;
    isFullyRendered: boolean;
    renderFailed: boolean;
    isTransitioningToFullRender: boolean;
}
/**
 * Handles virtualized rendering of PDF pages:
 * - placeholders for offscreen pages
 * - low-res “blurry” base renders
 * - high-res final renders
 * - text layer & annotation layers
 */
declare class PageVirtualization {
    private _options;
    private _scrollableContainer;
    private _pagesParentDiv;
    private _pageBuffer;
    private _totalPages;
    private _pdfDocument;
    private _pageWrapperPool;
    private _maxPooledWrappers;
    private _cachedPages;
    private _lastScrollTop;
    private _thumbnailViewer;
    private _pagePositions;
    private _pdfState;
    private _pdfViewer;
    private _selectionManager;
    private _searchHighlighter;
    private _canvasPool;
    private _boundOnScaleChange;
    private _isScaleChangeInProgress;
    private _resolveReadyPromise;
    private _pageIntersectionObserver;
    private _intersectionObserver;
    /**
     * @param options            Viewer configuration & container IDs.
     * @param scrollableContainer The scrollable wrapper element.
     * @param pagesParentDiv      The element into which page wrappers are inserted.
     * @param totalPages          Total number of PDF pages.
     * @param pdfViewer           Host WebViewer instance.
     * @param selectionManager    Manages text/annotation selection.
     * @param searchHighlighter   Highlights search matches.
     * @param pageBuffer          Number of pages to render around the viewport.
     */
    constructor(options: ViewerLoadOptions, scrollableContainer: HTMLElement, pagesParentDiv: HTMLElement, totalPages: number, pdfViewer: WebViewer, selectionManager: SelectionManager, searchHighlighter: SearchHighlighter, pageBuffer?: number);
    /**
     * Initializes page wrapper pool, computes positions, and sets up scroll/observer.
     */
    private _initAsync;
    _forceObservePage(): void;
    /**
     * Creates a pool of recycled page wrapper DIVs.
     */
    private _initializePageWrapperPool;
    /** Read-only map of cached page info. */
    get cachedPages(): ReadonlyMap<number, CachedPageInfo>;
    /** Read-only map of page top-offsets. */
    get pagePositions(): ReadonlyMap<number, number>;
    /**
     * Registers scroll and scale listeners.
     */
    private _attachScrollListener;
    /**
     * Retrieves an available page wrapper from the pool or creates a new one.
     * @returns {HTMLDivElement | null} The available page wrapper or null if not found.
     */
    private _getAvailablePageWrapper;
    /**
     * Releases a page wrapper back to the pool or removes it if transient.
     * @param wrapperDiv The wrapper DIV to release.
     */
    private _releasePageWrapper;
    /**
     * Sets the page intersection observer.
     * @param observer The IntersectionObserver instance.
     */
    set pageObserver(observer: IntersectionObserver);
    /**
     * Returns a read-only set of currently visible pages.
     * @returns {ReadonlySet<number>} Set of currently visible page numbers.
     */
    get currentlyVisiblePages(): ReadonlySet<number>;
    /**
     * Returns the page number being rendered if specific page rendering is enabled.
     * @returns {number | undefined | null} The page number or undefined if not set.
     */
    get isRenderingSpecificPageOnly(): number | undefined | null;
    /**
     * Returns the page positions map.
     * @returns {ReadonlyMap<number, number>} The page positions map.
     */
    get pagePositionsMap(): ReadonlyMap<number, number>;
    /**
     * Handles PDF scaleChange events.
     */
    private _onScaleChange;
    /**
     * Immediately updates the dimensions (CSS scaling) of currently visible and
     * fully rendered pages to reflect the new scale. This provides a quick,
     * blurry update during zoom. It also clears the high-resolution image container.
     */
    updateVisiblePageBuffers(): Promise<void>;
    /**
     * Resizes existing layer divs to match the new viewport dimensions.
     * @param pageInfo The page information object.
     * @param newViewport The new viewport dimensions.
     */
    private _resizeExistingLayerDivs;
    /**
     * Refreshes high-resolution images for currently visible pages.
     * @returns {Promise<void>}
     */
    refreshHighResForVisiblePages(): Promise<void>;
    /**
     * Updates the page for a new scale, including rendering and resizing.
     * @param pageInfo The page information object.
     */
    private _updatePageForNewScale;
    /**
     * Handles scroll events to update rendered pages.
     * @param event The scroll event.
     */
    private _scrollHandler;
    /**
     * Throttled scroll handler to update rendered pages.
     * @param isScaling Indicates if a scale change is in progress.
     */
    private _throttledScrollHandler;
    /**
     * Debounced function to ensure visible pages are rendered.
     * @returns {Promise<void>}
     */
    private _debouncedEnsureVisiblePagesRendered;
    /**
     * Ensures that visible pages are fully rendered.
     * @returns {Promise<void>}
     */
    private _ensureVisiblePagesRendered;
    /**
     * Fully renders the page content.
     * @param pageInfo The page information object.
     * @returns {Promise<void>}
     */
    private _transitionToFullRender;
    /**
     * Calculates the number of pages to render initially based on container height.
     * @returns {Promise<number>} Number of pages to render.
     */
    private _calculateInitialPagesToRender;
    /**
     * Renders only the specified page and clears others.
     * @param pageNumber The page number to render.
     */
    private _renderSpecificPageOnly;
    /**
     * Generates thumbnails for all pages.
     * @returns {Promise<void>}
     */
    generateThumbnails(): Promise<void>;
    /**
     * Calculates the positions of all pages in the document.
     * @returns {Promise<Map<number, number>>} A map of page numbers to their top offsets.
     */
    calculatePagePositions(): Promise<Map<number, number>>;
    /**
     * Determines the page number that is most centered in the viewport.
     * @param scrollTop The current scroll position.
     * @returns {number} The page number that is most centered in the viewport.
     */
    private _determineCenterPageInViewport;
    /**
     * Updates the rendered pages based on the current scroll position.
     * @param scrollTop The current scroll position.
     * @param isInitialLoad Indicates if this is the initial load.
     */
    private _updateRenderedPagesOnScroll;
    /**
     * Clears rendering artifacts for a page.
     * @param pageInfo The page information object.
     * @param destroyLayers Indicates if layers should be destroyed.
     */
    private _clearPageRenderArtifacts;
    /**
     * Adds a page to the DOM as a placeholder.
     * @param pageNumber The page number to add.
     * @returns {Promise<CachedPageInfo | undefined>} The cached page information or undefined if not added.
     */
    private _addPageToDom;
    /**
     * Renders the page content.
     * @param pageInfo The page information object.
     * @param viewport The viewport for rendering.
     * @returns {Promise<void>}
     */
    private _renderPageContent;
    /**
     * Ensures there’s a `<div id="canvasPresentation-<N>">` inside the
     * page wrapper div, and clears it if it exists.
     */
    private _ensureCanvasPresentationDiv;
    /**
     * Ensure there’s a `<div id="zoomedImageContainer-<N>">` inside the
     * canvasPresentation div, and size it to the full (high-res) viewport.
     */
    private _ensureImageContainerDiv;
    /**
     * Removes a page from the DOM and clears its resources.
     * @param pageNumber The page number to remove.
     */
    private _removePageFromDom;
    /**
     * Redraws all visible pages.
     * @returns {Promise<void>}
     */
    redrawAllVisiblePages(): Promise<void>;
    /**
     * Updates the page buffers for rendering.
     * @param pageNumber The page number to update.
     */
    updatePageBuffers(pageNumber?: number | null): Promise<void>;
    /**
     * Updates the styles and dimensions of the pages.
     * @param targetPageNumber The page number to update.
     */
    updatePageStylesAndDimensions(targetPageNumber?: number | null): Promise<void>;
    /**
     * Appends a high-resolution image to the page.
     * @param pageInfo The page information object.
     * @param viewport The viewport for rendering.
     */
    appendHighResImage(pageInfo: CachedPageInfo, viewport: PageViewport): Promise<void>;
    /**
     * Cleans up resources and removes event listeners.
     */
    destroy(): void;
}
export default PageVirtualization;
